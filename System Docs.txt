

BEVERAGE POS MULTI-AGENT SYSTEM ARCHITECTURE
=====================================================

OVERVIEW
--------
The Beverage POS system employs a sophisticated multi-agent architecture designed for real-time voice-controlled point-of-sale operations. The system consists of 5 primary agents working in concert to provide seamless voice interactions, business logic processing, and data management.

AGENT ARCHITECTURE BREAKDOWN
============================

1. VOICE PROCESSING AGENTS
--------------------------

1.1 Premium Voice Server (server/premium-voice-server.js)
- Technology Stack: WebRTC + Web Speech API
- Port: 3003 (Signaling), 3002 (Voice Processing)
- Capabilities:
  * Real-time WebRTC audio streaming
  * Wake word detection ("hey bev", "hey beverage", etc.)
  * Speech-to-text using browser's Web Speech API
  * Low-latency voice mode switching (wake_word → command → processing)
  * Client state management with inactivity timeouts
  * Heartbeat monitoring for connection health

1.2 Legacy Voice Server (server/voice-server.js)
- Technology Stack: Deepgram SDK + OpenAI
- Port: 3002
- Capabilities:
  * Deepgram-powered speech recognition
  * OpenAI TTS for voice responses
  * Agent state management (idle, listening, processing, speaking)
  * Real-time audio streaming via WebSocket
  * Noise filtering and audio preprocessing

Agent States:
- IDLE: Waiting for wake word
- LISTENING: Actively recording speech
- PROCESSING: Analyzing transcript and executing commands
- SPEAKING: Generating and playing audio response

2. CONVERSATIONAL AI AGENT
---------------------------

2.1 Intent Processor (server/intent-processor.js)
- Core Engine: Groq LLM (faster inference than OpenAI)
- NLU Framework: Custom intent classification + entity extraction
- Responsibilities:
  * Natural language understanding and intent classification
  * Conversation context management across sessions
  * Entity extraction (drink names, quantities, customer info)
  * Response generation with conversational personality
  * Error handling and fallback responses
  * Integration with TTS for voice responses

Intent Categories:
- cart_add, cart_remove, cart_view, cart_clear
- inventory_check, inventory_add
- order_create, payment_process
- conversation (general chat)
- menu_view, search_drinks

Context Management:
- Session-based conversation history
- Entity persistence across turns
- Contextual drink name resolution
- Payment method tracking

3. BUSINESS LOGIC AGENT
-----------------------

3.1 Voice Agent Service (lib/voice-agent-service.ts)
- Architecture: TypeScript service class with singleton pattern
- Database: Drizzle ORM + PostgreSQL/Supabase
- Core Functions:

Cart Management:
- addDrinkToCart(): Inventory-aware cart additions
- removeDrinkFromCart(): Quantity-based removal
- showCart(): Cart visualization with totals
- clearCart(): Session cart reset
- processOrder(): End-to-end order processing

Inventory Operations:
- searchDrinks(): Fuzzy search with caching
- getInventoryStatus(): Real-time stock levels
- Inventory validation before cart operations
- Cache management for performance

Analytics & Reporting:
- getOrderAnalytics(): Time-based sales analysis
- Revenue tracking and average order value
- Order status monitoring

Event Management:
- listEventPackages(): Predefined event packages
- bookEvent(): Customer and venue booking
- Integration with customer management

4. DATABASE & TOOLS AGENT
--------------------------

4.1 MCP Server (scripts/mcp-server.js)
- Protocol: Model Context Protocol for tool execution
- Database: Direct PostgreSQL via postgres.js driver
- Architecture: Stateless tool execution server

Core Tools:
- check_inventory: Stock level queries
- add_inventory: Inventory adjustments
- cart_*: Cart management operations
- create_order: Order processing with transactions
- view_menu: Menu retrieval
- payment_*: Payment processing simulation

Advanced Tools:
- update_drink_inventory: Granular stock updates
- bulk_update_inventory: Batch operations
- get_low_inventory_bottles: Stock alerts
- create_drink: Menu item creation
- health_check: System health monitoring

Transaction Management:
- PostgreSQL transactions for order processing
- Inventory deduction with rollback capability
- Payment processing simulation
- Error handling with transaction rollback

5. COMMUNICATION AGENT
----------------------

5.1 MCP Client (server/mcp-client.js)
- Role: Inter-agent communication orchestrator
- Architecture: Persistent connection manager with reconnection logic
- Responsibilities:
  * Tool execution routing to MCP Server
  * Connection health monitoring and reconnection
  * Request queuing during disconnections
  * Error handling and timeout management
  * Process lifecycle management

Connection Management:
- Automatic process spawning and cleanup
- Exponential backoff reconnection strategy
- Request queuing during outages
- Heartbeat monitoring (30s intervals)
- Graceful shutdown handling

AGENT COMMUNICATION FLOW
=========================

Primary Flow:
Voice Input → Voice Server → Intent Processor → MCP Client → MCP Server → Database
                    ↓
Voice Agent Service ← Business Logic Processing

Detailed Interaction Sequence:
1. Voice Server captures audio and converts to text
2. Intent Processor analyzes transcript for intent + entities
3. Intent Processor routes tool calls via MCP Client
4. MCP Client forwards requests to MCP Server
5. MCP Server executes database operations
6. Results flow back through the chain
7. Voice Agent Service provides business logic validation
8. Intent Processor generates conversational response
9. TTS converts response to audio
10. Voice Server plays audio to user

INTER-AGENT PROTOCOLS
=====================

1. WebSocket Communication:
- Voice Servers ↔ Frontend: Real-time audio streaming
- Message types: transcript, agent_state, mode_change, ping/pong

2. MCP Protocol:
- Structured JSON-RPC for tool execution
- Request/response with unique IDs
- Error propagation and timeout handling

3. HTTP APIs:
- REST endpoints for traditional web interface
- Voice cart synchronization endpoints
- Real-time inventory status APIs

DATA FLOW & SYNCHRONIZATION
============================

Session Management:
- Voice sessions identified by WebSocket connection
- Cart state maintained in-memory with clientId mapping
- Payment method selection persisted per session

Real-time Synchronization:
- Voice cart changes reflected in web UI via polling
- Inventory updates propagated across all agents
- Order status updates broadcast to relevant sessions

Caching Strategy:
- Drink search results cached for performance
- Inventory status cached with TTL
- Menu data cached to reduce database load

ERROR HANDLING & RESILIENCE
============================

Agent-Level Resilience:
- Each agent handles its own error states
- Graceful degradation when dependencies fail
- Automatic reconnection for network failures

Cross-Agent Error Propagation:
- Errors bubble up through the communication chain
- Fallback responses for critical failures
- User-friendly error messages via conversational AI

Database Transaction Safety:
- All order operations wrapped in transactions
- Inventory updates with rollback capability
- Consistency checks before order completion

PERFORMANCE CHARACTERISTICS
============================

Latency Targets:
- Voice recognition: <200ms
- Intent processing: <500ms
- Database operations: <100ms
- End-to-end voice response: <1s

Scalability Considerations:
- Stateless MCP Server for horizontal scaling
- Connection pooling for database operations
- In-memory caching for frequently accessed data

Throughput Capabilities:
- Multiple concurrent voice sessions
- Real-time inventory updates
- High-frequency cart operations

DEPLOYMENT ARCHITECTURE
=======================

Process Distribution:
- Voice Servers: Independent processes on dedicated ports
- MCP Server: Spawned child process with stdio communication
- Web Server: Next.js application server
- Database: External Supabase/PostgreSQL instance

Port Allocation:
- 3000: Next.js web server
- 3002: Voice processing server
- 3003: WebRTC signaling server
- 5432: PostgreSQL database (external)

Environment Configuration:
- OpenAI API keys for LLM and TTS
- Deepgram API key for speech recognition
- Supabase connection strings
- ElevenLabs API for premium TTS

MONITORING & OBSERVABILITY
===========================

Health Checks:
- Individual agent health monitoring
- Database connection health
- API service availability checks

Logging Strategy:
- Structured logging across all agents
- Error tracking with stack traces
- Performance metrics collection

Debugging Capabilities:
- Voice debug components for real-time monitoring
- Request/response logging for MCP communications
- Transaction logging for database operations

SECURITY CONSIDERATIONS
=======================

Authentication:
- API key management for external services
- Secure WebSocket connections
- Database connection encryption

Data Protection:
- Customer information handling
- Payment data security (simulation only)
- Session isolation and cleanup

Network Security:
- TLS for external API communications
- Local-only MCP communications
- Firewall considerations for voice ports

FUTURE EXTENSIBILITY
====================

Planned Enhancements:
- Additional voice providers (Azure, AWS)
- Multi-language support
- Advanced analytics and reporting
- Real payment gateway integration
- Multi-venue support

Agent Extension Points:
- Plugin architecture for new tools
- Configurable intent classification
- Custom business logic modules
- Third-party integrations

This multi-agent architecture provides a robust, scalable foundation for voice-controlled commerce applications while maintaining clear separation of concerns and fault tolerance. 